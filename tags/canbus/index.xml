<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>canbus on technical_</title><link>https://blog.agramakov.me/tags/canbus/</link><description>Recent content in canbus on technical_</description><generator>Hugo</generator><language/><lastBuildDate>Sun, 18 Sep 2022 21:48:21 +0100</lastBuildDate><atom:link href="https://blog.agramakov.me/tags/canbus/index.xml" rel="self" type="application/rss+xml"/><item><title>Zakhar Brain Service</title><link>https://blog.agramakov.me/posts/2022/09-18-zakhar-brain-service/</link><pubDate>Sun, 18 Sep 2022 21:48:21 +0100</pubDate><guid>https://blog.agramakov.me/posts/2022/09-18-zakhar-brain-service/</guid><description><p>Yesterday I merged a big software update to the Zakhar&rsquo;s Raspberry Pi Unit -<code>brain_service</code>.</p><p>The update brings a service providing the robot&rsquo;s status (network, OS status) and access to the CAN bus for many simultaneously connected clients. Also, the service tracks the presence of other robot Units on the CAN bus.</p><p>There is another service shipping with the same repository<code>brain_service_display</code>. This service connects to<code>brain_service</code> and shows some important information on a small OLED display:</p><p><img class="img-zoomable" src="screen1.jpg" alt=""/><img class="img-zoomable" src="screen2.jpg" alt=""/><img class="img-zoomable" src="screen3.jpg" alt=""/></p><ul><li>f - Face Unit</li><li>S - Sensor Unit</li><li>m - Wheeled moving platform (&ldquo;Motors&rdquo;)</li><li>t - Service Unit (&ldquo;Tool&rdquo;)</li></ul><p>The service structure is presented below:</p><p><img class="img-zoomable" src="structure.svg" alt=""/></p><p>The service publishes status information and incoming CAN messages to<a href="https://zeromq.org/" target="_blank">ZeroMQ</a> subscribers. The service allows all TCP connections including connections from external machines. See<a href="https://github.com/Zakhar-the-Robot/brain_pycore" target="_blank">brain_pycore</a> for compatible subscriber and client implementation classes.</p><p>Sources:</p><ul><li><a href="https://github.com/Zakhar-the-Robot/brain_service" target="_blank">https://github.com/Zakhar-the-Robot/brain_service</a></li><li><a href="https://github.com/Zakhar-the-Robot/brain_pycore" target="_blank">https://github.com/Zakhar-the-Robot/brain_pycore</a></li></ul></description></item><item><title>Brain Software Architecture</title><link>https://blog.agramakov.me/posts/2022/08-31-brain-software-architecture/</link><pubDate>Wed, 31 Aug 2022 19:58:42 +0100</pubDate><guid>https://blog.agramakov.me/posts/2022/08-31-brain-software-architecture/</guid><description><p>Before updating Alive OS to support<a href="https://zakhar-the-robot.github.io/doc/docs/communication-protocols/canbus/" target="_blank">qCAN (my CANbus-based protocol)</a> I have the last thing to do. To simplify my live in future I need a CAN publisher that can publish messages to many subscribers. My main subscribe of course is AliveOS but also to display information about connected devices I need a second subscriber - a service listening only qCAN Present messages.</p><p>To do it I will use a<a href="https://zeromq.org/" target="_blank">ZeroMQ protocol</a> - an extremely supported and documented for many programming languages standard. I&rsquo;m going to update my brain_service to support the protocol and it will be responsible for all interaction with Raspberry Pi.</p><p><img class="img-zoomable" src="Brain_Structure.png" alt=""/></p><p>Repositories:</p><ul><li><a href="https://github.com/Zakhar-the-Robot/brain_pycore" target="_blank">https://github.com/Zakhar-the-Robot/brain_pycore</a></li><li><a href="https://github.com/Zakhar-the-Robot/brain_service" target="_blank">https://github.com/Zakhar-the-Robot/brain_service</a></li></ul></description></item><item><title>Sensor Unit with qCAN Support is Merged!</title><link>https://blog.agramakov.me/posts/2022/08-17-sensor-unit-with-qcan-support-is-merged/</link><pubDate>Wed, 17 Aug 2022 19:53:46 +0100</pubDate><guid>https://blog.agramakov.me/posts/2022/08-17-sensor-unit-with-qcan-support-is-merged/</guid><description><p><img class="img-zoomable" src="2.jpg" alt=""/></p><p>Updated code for the Sensor Unit with qCAN support is merged and documented!</p><ul><li>Source code:<a href="https://github.com/Zakhar-the-Robot/io_sensors" target="_blank">https://github.com/Zakhar-the-Robot/io_sensors</a></li><li>Documentation:<a href="https://zakhar-the-robot.github.io/doc/docs/systems/io_sensors/" target="_blank">https://zakhar-the-robot.github.io/doc/docs/systems/io_sensors/</a></li></ul><p><img class="img-zoomable" src="1.jpg" alt=""/></p></description></item><item><title>The Wheeled Platform with CAN support is merged!</title><link>https://blog.agramakov.me/posts/2022/08-09-the-wheeled-platform-with-can-support-is-merged/</link><pubDate>Tue, 09 Aug 2022 19:45:42 +0100</pubDate><guid>https://blog.agramakov.me/posts/2022/08-09-the-wheeled-platform-with-can-support-is-merged/</guid><description><p>A new step in Zakhar global transition to CAN bus is done!</p><div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;"><iframe src="https://www.youtube.com/embed/0DVqdEvbaGk" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen= title="YouTube Video"/></div><p>The unit consists of:</p><ul><li>ESP32 DevKit V1 - 36 pins</li><li>GY-91 - MPU module</li><li>HW-021 TJA1050 - CAN-bus driver</li><li>Red-Green LED module</li></ul><p>It can be controlled via CANbus, Serial and Bluetooth.</p><p>The documentation page is available here:</p><p><a href="https://zakhar-the-robot.github.io/doc/docs/systems/motion/wheeled-platform/" target="_blank">https://zakhar-the-robot.github.io/doc/docs/systems/motion/wheeled-platform/</a></p></description></item><item><title>New Zakhar Face Module</title><link>https://blog.agramakov.me/posts/2022/08-07-new-zakhar-face-module/</link><pubDate>Sun, 07 Aug 2022 21:44:38 +0100</pubDate><guid>https://blog.agramakov.me/posts/2022/08-07-new-zakhar-face-module/</guid><description><p><img class="img-zoomable" src="IMG_20220807_210614803.jpg" alt=""/></p><p>The new Unit is based on the ESP-Wrover-Kit and uses a TJA1050 module for CANbus communication.</p><p>It is compatible with the qCAN protocol (described on the Zakhar main page) and can show 5 facial expressions: Anger (0x32), Sadness (0x34), Pleasure (0x33), a Blink (0x31), and Calm (0x30).</p><p>To control it you should send a CAN message with an expression code using a 125Kbit standard CAN frame and with the message id ending with byte 0x4. E.g. send a message with ID: 0x004, data: 0x33 to make Zakhar happy üòç.</p><p><a href="https://zakhar-the-robot.github.io/doc/docs/systems/io/face/" target="_blank">Read more on the Zakhar main page</a>.</p></description></item><item><title>CAN Bus and a New Simple Protocol</title><link>https://blog.agramakov.me/posts/2022/07-21-can-bus-and-a-new-simple-protocol/</link><pubDate>Thu, 21 Jul 2022 20:28:27 +0100</pubDate><guid>https://blog.agramakov.me/posts/2022/07-21-can-bus-and-a-new-simple-protocol/</guid><description><h2 id="not-only-two-wires">Not Only Two Wires</h2><p>It‚Äôs been more than two years already since I started working on my robot Zakhar. The Zakhar 1 was built out of Lego and relied on I2C communication between modules. It was a nightmare because as it turned out each MCU developer has its own understanding of how a developer should interact with the I2C unit. What I wanted from the interface:</p><p><img class="img-zoomable" src="CAN%20bus%20and%20a%20new%20simple%20protocol%20b5025925c93f493abf97425c9879981d/Untitled.png" alt="I2C makes robots sad"/></p><ul><li>Main/secondary nodes interaction</li><li>Understand what devices are in the network</li><li>Send commands</li><li>Receive sensor data</li></ul><p>To make all this possible I‚Äôve developed a simple I2C-based protocol but couldn‚Äôt get the desired behavior (read more in<a href="https://hackaday.io/project/171888-zakhar-the-robot/log/196935-dear-i2c-i-resemble" target="_blank">my post</a>) on all platforms - Raspberry Pi, STM32, Arduino, and ESP32. Overly Zakhar 1 had too many problems to continue the project - mechanically it was floppy, power sources were unstable, the display was flickering, and the interface‚Ä¶ It was too distracting, unstable, and annoying to continue!</p><p>I started Zakhar 2 based on the CAN interface. Why CAN? There are many advantages of CAN compared to I2C:</p><ul><li>Better MCU developer support</li><li>A single data frame contains much more information than I2C</li><li>Physical layer - actually not specified, but de-facto it is RS485 and it is much suitable for heterogeneous systems with several power sources:<ul><li>Really two-wires interface, without a common ground</li><li>No voltage levels shifters</li></ul></li><li>Embedded addressing mechanism</li><li>Still simple</li></ul><p>There are cons of course. The main one is that not all platforms have hardware CAN bus support. But there are many external modules on the market, there are tons of drivers developed for all platforms, and there are thousands of guides written, so it is easy to mitigate.</p><h2 id="yes-a-new-protocol">Yes, a new protocol!</h2><p><img class="img-zoomable" src="CAN%20bus%20and%20a%20new%20simple%20protocol%20b5025925c93f493abf97425c9879981d/Untitled%201.png" alt="CAN is used in vehicles and has many flavors"/></p><p>I like developing standards. I really wanted to invent my own bicycle. Also, I wanted to make a transition from I2C to CAN smooth keeping all implemented features and continuing established directions. And likely for Zakhar 2, there was no good candidate. Had no reason not to develop my own CAN-based protocol. Here is not the full list of my options with the main reason to say no:</p><ul><li><a href="https://en.wikipedia.org/wiki/CANopen" target="_blank">CANopen</a> - too complex</li><li><a href="https://en.wikipedia.org/wiki/DeviceNet" target="_blank">DeviceNet</a> - CIP, not needed (hello my employer!)</li><li><a href="https://en.wikipedia.org/wiki/SAE_J1939" target="_blank">SAE_J1939</a> - too complex</li><li><a href="https://en.wikipedia.org/wiki/CANaerospace" target="_blank">CANaerospace</a> - too complex</li><li><a href="https://en.wikipedia.org/wiki/Cubesat_Space_Protocol" target="_blank">Cubesat_Space_Protocol</a> - better, good support, but excessive</li><li><a href="https://en.wikipedia.org/wiki/Very_Simple_Control_Protocol" target="_blank">Very_Simple_Control_Protocol</a> - not<strong>very</strong> simple</li></ul><h2 id="the-bicycle">The Bicycle</h2><p><img class="img-zoomable" src="CAN%20bus%20and%20a%20new%20simple%20protocol%20b5025925c93f493abf97425c9879981d/Untitled%202.png" alt="Old Bicycle"/></p><p>It is turned out, that I don‚Äôt need to build a lot on top of bare CAN. The protocol is based on the usage of the ID field of the CAN frame. The field carries all the necessary information for the protocol. Here are some illustrations for the Standard and the Extended CAN frame (my know-how is in green):</p><p><img class="img-zoomable" src="CAN%20bus%20and%20a%20new%20simple%20protocol%20b5025925c93f493abf97425c9879981d/canbus_frame_std.svg" alt="Standard Frame"/></p><p><img class="img-zoomable" src="CAN%20bus%20and%20a%20new%20simple%20protocol%20b5025925c93f493abf97425c9879981d/canbus_frame_ext.svg" alt="Extended Frame"/></p><p>Each device has its own address, an ID. Information about the source, the destination, and the message type is embedded info the ID filed in a way that makes it simple to read by a human in HEX format. For example, if the device with the id #5 sends a message of type 1 to device #3, the message ID will be<strong>0x531</strong> and<strong>0x0503001</strong> for the standard and the extended frames respectively.</p><p>Since CAN bus devices by default are constantly sending data in the network I used it for device discovery. All devices should send a Presence message at least once in 3 seconds. If not, the device is considered disconnected.</p><p><img class="img-zoomable" src="CAN%20bus%20and%20a%20new%20simple%20protocol%20b5025925c93f493abf97425c9879981d/Untitled%203.png" alt="Presence Messages"/></p><p>With such a message structure, it is very simple to address commands not only to a specific device but also to broadcast them using the destination of 0x0. Also sending data information can be broadcasted as well as dedicated to a specific device:</p><p><img class="img-zoomable" src="CAN%20bus%20and%20a%20new%20simple%20protocol%20b5025925c93f493abf97425c9879981d/Untitled%204.png" alt="Commands"/></p><p>Commands</p><p><img class="img-zoomable" src="CAN%20bus%20and%20a%20new%20simple%20protocol%20b5025925c93f493abf97425c9879981d/Untitled%205.png" alt="Data Messages"/></p><p>Data Messages</p><p>The full protocol description is available on the Zakhar documentation page here:</p><p><a href="https://zakhar-the-robot.github.io/doc/docs/communication-protocols/canbus/" target="_blank">https://zakhar-the-robot.github.io/doc/docs/communication-protocols/canbus/</a></p><h2 id="whats-next">What‚Äôs Next?</h2><p>I‚Äôm finishing the firmware implementation for all my robot units. In the next article, I want to talk about the<strong>protocol implementation in the Zakhar the Robot project</strong>.</p><h2 id="nice-but-whats-about-the-alive-robot">Nice but What‚Äôs About the Alive Robot?</h2><p>The main purpose of the project is to investigate the potential of animal-like behavior for the human-robot interaction. It is a big sophisticated topic and working on this demands a reliable hardware basis. I plan to spend some more time working on this. Then I will return to the high-level problem. Also, as I am a low-level developer I know that the hardware architecture defines high-level possibilities so it is important to make it right. Thanks for your patience and stay tuned!</p><h2 id="links">Links</h2><ul><li><a href="https://blog.agramakov.me/" target="_blank">My blog</a></li><li><a href="https://zakhar-the-robot.github.io/doc/docs/communication-protocols/canbus/" target="_blank">Standard Documentation</a></li><li><a href="https://www.facebook.com/groups/zakhartherobot" target="_blank">Facebook</a></li><li><a href="https://www.instagram.com/zakhar_the_robot" target="_blank">Instagram</a></li><li><a href="https://hackaday.io/project/171888-zakhar-the-robot" target="_blank">Hackaday.io project page</a></li></ul></description></item></channel></rss>